= A List of +python+ Tips, Tricks and recipes/idioms
:Author:                Christoph Hoffmann
:Email:                 choffmann1983@gmail.com
:Revision:              0.0.1 'http://semver.org/[(semver)]'
:source-highlighter:    highlight
:numbered:
:toc:                   // set table of content
:icons:                 // search for icons in :inconsdir: (default: ./images/icons.)
:iconsdir:              ../asciidoc/images/icons
:imagesdir:             ../asciidoc/images/
// :scriptsdir:            ../asciidoc/js
// :linkcss:

:language:              python

== Introduction

todo ...

Here is a list of interesting links:

* http://ivory.idyll.org/articles/advanced-swc/[Intermediate and Advanced Software Carpentry in Python]
* http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html[Code Like a Pythonista: Idiomatic Python]
* http://code.activestate.com/recipes/langs/python/[Popular Python recipes ]

== Shebang 

[TIP]
==========================
Detailed description at source: https://en.wikipedia.org/wiki/Shebang_(Unix)[wikipedia.org]
==========================

Shebang is used to let the operation system know how to interpret the given script. Shebangs have to be place on the first line of code.

[source,python]
----
#!/usr/bin/env python
----


== Docstrings

[TIP]
==========================
* https://en.wikipedia.org/wiki/Docstring#Python[python wiki]
* http://tovid.wikia.com/wiki/Python_tips/Docstrings[Docstring]
* http://www.onlamp.com/lpt/a/python/2001/05/17/docstrings.html[tips and tricks]
==========================


=== Docstring convention

[TIP]
==========================
* http://www.python.org/dev/peps/pep-0257/[convention]
* https://code.google.com/p/google-styleguide/[google-styleguide]
* http://google-styleguide.googlecode.com/svn/trunk/pyguide.html[pyguide]
==========================

== Enum in python

In python exists no Enum type. So, it has to be created manually. This example demonstrates a way of creating Enums with dictionaries.

.Workaround to create Enums in python
[source,python]
----
def enum(*sequential, **named):
    '''
    Example:  num = enum(ONE=1, TWO=2, THREE='three')
              num.ONE >>> 1
    Support for converting the values back to names can be added this way:
              num.reverse_mapping[2] >> 'TWO'
    Source: http://stackoverflow.com/a/1695250
    '''
    enums = dict(zip(sequential, range(len(sequential))), **named)
    reverse = dict((value, key) for key, value in enums.iteritems())
    enums['reverse_mapping'] = reverse
    return type('Enum', (), enums)
----    


== Python Imaging Library (http://www.pythonware.com/products/pil/[PIL])

PIL is a good library to handle images in python.

Installing the PIL on Ubuntu 64 bit revealed some issues.

[quote, anonymous]
It turns out that the APT installations put the libraries under '/usr/lib/x86_64-linux-gnu' and PIL will search for them in '/usr/lib/'. So you have to create symlinks for PIL to see them.

[source,shell]
----
ln -s /usr/lib/x86_64-linux-gnu/libjpeg.so /usr/lib
ln -s /usr/lib/x86_64-linux-gnu/libfreetype.so /usr/lib
ln -s /usr/lib/x86_64-linux-gnu/libz.so /usr/lib
----
Source: http://jj.isgeek.net/2011/09/install-pil-with-jpeg-support-on-ubuntu-oneiric-64bits/



== Importing libs in main only

Sometimes libs are only needed if a lib is called as main process. Thus, it is meaningful to import such libs only if this module is called as main process. 

[source,python]
----
if __name__ == '__main__':
    from paste import httpserver    # Paste <http://pythonpaste.org>
    httpserver.serve(app, host='127.0.0.1', port=8080)  
----

or

[source,python]
----
if __name__ == '__main__':
    import sys
    main(sys.argv[1:])
----


== File handling 

[TIP]
Detailed description at source: http://docs.python.org/2/tutorial/inputoutput.html#methods-of-file-objects[docs.python.org]

It is good practice to use the `with` keyword when dealing with file objects. This has the advantage that the file is properly closed after its suite finishes, even if an exception is raised on the way. It is also much shorter than writing equivalent try-finally blocks:

[source,python]
----
with open('workefile', 'r') as f:
    read_data = f.read()

doOtherStuff()  # <1>
----
<1> f is closed here automatically even if  an exception raised

or with multiple files

[source,python]
----
with open('a', 'w') as a, open('b', 'w') as b:
    data_a = a.read()
    data_b = b.read()

doOtherStuff()  # <1>
----
<1> a and b are closed here automatically even if  an exception raised

=== Reading file in one line

[source]
----
def _read(filename):
    return [line.split() for line in open(filename)]
----


:test_link: http://www.python.org/dev/peps/pep-0008/#global-variable-names[#]
== \_\_all__ mechanism

Use \_\_all__ mechanism to prevent name clashes if you import a module by _from M import *_ [Source: {test_link}]

.foobar.py
[source,python]
----
# Specify what is visible from other modules if current module imported by
# from M import *
__all__ = ['foobar'] # only foobar is visible


foobar = 'hey'
foobarprivate = 'should not be seen'
----

.main.py
[source,python]
----
from foobar import *

foobar          # <1>
foobarprivate   # <2>
----
<1> Ok
<2> Error


== Class to handle a bunch of different variables 

[TIP]
Detailed description at source: http://code.activestate.com/recipes/52308-the-simple-but-handy-collector-of-a-bunch-of-named/?in=user-97991[code.activestate.com]

[source, python]
----
class Bunch(dict):
    def __init__(self, **kw):
        dict.__init__(self, kw)     # <1>
        self.__dict__.update(kw)

# that's it!  Now, you can create a Bunch
# whenever you want to group a few variables:

point = Bunch(datum=y, squared=y*y, coord=x)

# and of course you can read/write the named
# attributes you just created, add others, del
# some of them, etc, etc:
if point.squared > threshold:
    point.isok = 1
----

<1> This has the added benefit that it can directly be printed and it shows its contents in interactive environments like ipython.


== Dictionary default value 

[TIP]
Detailed description at source: http://stackoverflow.com/questions/101268/hidden-features-of-python[stackoverflow.com]

[source,python]
----
d = {}                      # empty dictionary
dafaultKey = 1234           # default value for key
d['key']                    # -> exception 'KeyError'
d.get('key')                # -> None
d.get('key', dafaultKey)    # -> defaultKey = 1234
# Great for:
d['key'] = d.get('key', dafaultKey) + 1
----

=== Dictionary and default v2
Assuming you have an unknown number of parameters which have to be set to a default. For instance see following example:

.Example code 
[source]
-------------------------
class SomeClass(object):
    __init__(self, x, y, *args, **kwargs):
        self.x = x
        self.y = y
        self.args = args
        self.kwargs = kwargs
        
    run(self, **kwargs):
        lskws = dict(mandatory1=10, mandatory2=2)
        lskws.update(self.kwargs)
        lskws.update(kwargs)
        doCoolStuff(**lskws)
-------------------------
In this example you can provide the parameter "globally" with the constructor or 
by the function `run`. Here `mandatory1` and `mandatory2` are variables which 
are required for the later function call and will be set locally in the function
to default values. The values, along with other parameters, will be overwritten 
by the internal values in the property `self.kwargs` or by the provided parameters
in `kwargs`. 

The order here is, take the values provided by `kwarags`. If not provided, take
the parameters provided by `self.kwargs`. If not provided, take default values 
of local parameters in `lskws`.


== How to write binary bits to a file

[source,python]
----
import struct                               # <1>

num = [1,2,3,4]

# 'B' : unsigned byte -> 0..255
data = struct.pack('BBBB', *num)            # <2>
# more general:
data = struct.pack('B' * len(num), *num)    # <2>

filename = 'test.bin'
with open(filename, 'wb') as f:
    f.write(data)
----

<1> Link: http://docs.python.org/2/library/struct.html[struct]
<2> Link: http://docs.python.org/2/library/struct.html#struct.pack[struct.pack]


== Mandatory vs. Optional Arguments

Sometimes it is useful to have arguments which are mandatory while others are not necessary because they can be predicted, inferred by other values or they have some default values.

[source,python]
----
def func(v1, v2, **args):
    defaultV3 = -1
    v3 = args.get('v3', defaultV3)
    print v1, v2, v3

func(1, 2, v3=22)       # <1>
func(1, 2)              # <2>
----
<1> >>> 1  2 22
<2> >>> 1 2 -1


== List all Folders

[source,python]
----
import os


folder = [f for f in os.listdir('.') if os.path.isdir(f)]                       # <1>

of = '/path/to/other/folder'         # working folder
folder = [f for f in os.listdir(of) if os.path.isdir(os.path.join(of, f))]      # <2>
----

<1> Only works if one is looking for folders in the current folder
<2> More general case



== List Comprehensions 

[TIP]
Detailed description at source: http://docs.python.org/2.7/tutorial/datastructures.html#list-comprehensions[docs.python.org]

Compact way to generate specific lists.

[source,python]
----
[(x, y) for x in [1, 2, 3] for y in [3, 1, 5] if x!=z]  # <1>
----

<1> >>> [(1, 3), (1, 5), (2, 3), (2, 1), (2, 5), (3, 1), (3, 5)]

=== Unpacking list in list

[source,python]
----
vec = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
[num for elem in vec for num in elem]   # <1>
----

<1> >>> [1, 2, 3, 4, 5, 6, 7, 9]

=== Nested list comprehension

[source,python]
----
matrix = [
    [1, 5, 9],
    [2, 6, 10],
    [3, 7, 11],
    [4, 8, 12]
]

matrix_trans = [[row[n] for row in matrix] for n in range(len(matrix))]  
print matrix_trans      # <1>
----

<1> >>> \[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]


=== Slice copy when changing a list while iterate over same list

To change a sequence you are iterating over while inside the loop (for example to duplicate certain items), it is recommended that you first make a copy. Looping over a sequence does not implicitly make a copy. The slice notation makes this especially convenient [http://docs.python.org/2.7/tutorial/datastructures.html#looping-techniques[#]]:

[source,python]
----
words = ['cat', 'window', 'defenestrate']
for w in words[:]:  # Loop over a slice copy of the entire list.
    if len(w) > 6:
        words.insert(0, w)

words       # <1>
----

<1> >>> ['defenestrate', 'cat', 'window', 'defenestrate']

== Looping Techniques 

[TIP]
==========================
* Detailed description at source: http://docs.python.org/2.7/tutorial/datastructures.html#looping-techniques[docs.python.org]
* todo
==========================


=== List

To retreive index and value use `enumerate()`.

[source,python]
----
for i, v in enumerate(['tic', 'tac', 'toe']):
    print i, v
----

=== Dictionary

Iterate over the complete dictionary.

[source,python]
--------------------------
knights = {'gallahad': 'the pure', 'robin': 'the brave'}
for k, v in knights.iteritems():
    print k, v
--------------------------


== How to determine type of variable

[source, python]
--------------------------
type([]]) is list   # <1>
--------------------------
<1> `>>> True`

.Examples
[source, python]
--------------------------
i = 123
type(i)             # <1>
type(i) is int      # <2>
i = 123456789L
type(i)             # <3>
type(i) is long     # <4>
i = 123.456
type(i)             # <5>
type(i) is float    # <6>
--------------------------
<1> `>>> <type 'int'>`
<2> `>>> True`
<3> `>>> <type 'long'>`
<4> `>>> True`
<5> `>>> <type 'float'>`
<6> `>>> True`


== String formatting

[TIP]
==========================
* http://docs.python.org/2.7/tutorial/inputoutput.html[inputoutput.html]
==========================

.Using .format()
[source, python]
--------------------------
print 'We are the {} who say "{}!"'.format('knights', 'Ni')     # <1>
--------------------------
<1> `>>> We are the knights who say "Ni!"`

or

=== Positioning of format fields

The brackets and characters within them (called format fields) are replaced with the objects passed into the `str.format()` method. A number in the brackets refers to the position of the object passed into the `str.format()` method.

.With numbers
[source, python]
--------------------------
print '{0} and {1}'.format('spam', 'eggs')      # <1>

print '{1} and {0}'.format('spam', 'eggs')      # <2>
--------------------------
<1> `>>> spam and eggs`
<2> `>>> eggs and spam`

.With keys
[source, python]
--------------------------
print 'This {food} is {adjective}.'.format(food='spam', adjective='absolutely horrible')    # <1>
--------------------------
<1> `>>> This spam is absolutely horrible.`


== Variable number of arguments

[TIP]
==========================
* http://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/[how-to-use-args-and-kwargs-in-python]
==========================

.Multiple key-value arguments
[source]
--------------------------
def myfunc(**kwargs):
    # kwargs is a dictionary.
    for k,v in kwargs.iteritems():
         print "%s = %s" % (k, v)

myfunc(abc=123, efh=456)        # <1>

keywords = {'abc': 123, 'efh': 456}
myfunc(**keywords)              # <2>
--------------------------
<1> `>>> abc = 123`
+
`>>> efh = 456`

<2> <1> and <2> are equivalent


.Mix of list an key-value arguments
[source]
--------------------------
def myfunc2(*args, **kwargs):   # <1>
   for a in args:
       print a
   for k,v in kwargs.iteritems():
       print "%s = %s" % (k, v)

myfunc2(1, 2, 3, banan=123)     # <2>

keywords = {'banan': 123}
listargs = [1,2,3]
myfunc2(*listargs, **keywords)     # <3>
--------------------------
<1> `*args` = list arguments; `**kwargs` = keyword arguments
<2> `>>> 1` 
+
`>>> 2`
+
`>>> 3` 
+
`>>> banan = 123`

<3> -> <2> and <3> are equivalent


== **kwargs vs. named arguments (keywords)
In many cases it is useful to provide a variable number of arguments. Often many arguments 
can be inferred or set to a default value. This can be done
by `def func1(*args, **kwargs)` or `def func2(x, *args, plot=True, debug=True)`.
So, when to use which idiom? 

While the fromer version has the main advantage that the
list of named arguments is more arbitrary than the latter, it's readability is much
worse. For example one caller has to read the docstring assuming their exists one and
it is consistent with the source code or, worse, he has to read the source code. 
Also, the latter version provides a fast grasp of the possible arguments and assuming
the arguments are given appropriate names, the user understands its meaning without
reading the docstring or source code at all. 

Furthermore, the latter version could be called with positional
arguments like `func2(x, y, True, False)` while the latter version always has to be called
like `func1(x, y, plot=True, debug=False)`. A good example is the 
http://docs.python.org/2/library/subprocess.html#popen-constructor[subprocess.Popen]
Construrctor:

.Example
[source]
--------------------------
class Popen(object):
    def __init__(self, args, bufsize=0, executable=None,
                 stdin=None, stdout=None, stderr=None,
                 preexec_fn=None, close_fds=False, shell=False,
                 cwd=None, env=None, universal_newlines=False,
                 startupinfo=None, creationflags=0):
        """Create new Popen instance."""
        ...
--------------------------

While there exist reasons to use the former version, my suggestion would be 
to use the latter version `def func2(x, *args, plot=True, debug=True)` in most cases.

If you want, for some reason, ensure that some arguments are "keyword-only" arguments 
and thus will never be automatically filled in by positional argument, the 
http://www.python.org/dev/peps/pep-3102/[pep3102] is the way to go.

.2 Positional arguments and keywords arguments
[source]
--------------------------
def compare(a, b, *ignore, key=None):
    if ignore:  # If ignore is not empty
        raise TypeError
    ...
--------------------------

In this case `compare(1,2,'key')` will result in an error while `compare(1,2,key='key')`
or `compare(1,2)` will give the intended behavior.

The former version should be used if the number and/or names of the arguments is
not known in advanced. For example for writing a wrapper function which mainly calls
another function and where the parameter only should be passed on to the other 
function. A good example is the `subprocess.call` function which is in
principle only a wrapper function which creates a `Popen` object and waits until
the process has been finished.

.Example call of subprocess package
[source]
--------------------------
def call(*popenargs, **kwargs):
    """Run command with arguments.  Wait for command to complete, then
    return the returncode attribute.

    The arguments are the same as for the Popen constructor.  Example:

    retcode = call(["ls", "-l"])
    """
    return Popen(*popenargs, **kwargs).wait()
--------------------------

The main advantage here is that, suppose the argument list in the `Popen` 
constructor changed, the `call` function does not have to be changed at all. Thus
there is no additional maintenance here as it would be in the other case.


=== Mixins with default values

[TIP]
==========================
* http://www.network-theory.co.uk/docs/pytut/DefaultArgumentValues.html[DefaultArgumentValues]
==========================

[WARNING]
==========================
*Important warning*: The default value is evaluated only once. This makes a difference when the default is a mutable object such as a list, dictionary, or instances of most classes. Thus, it is often better to have a default value of `None` and create the default object inside the function.
==========================

Often it is useful to provide default values for the arguments which haven't been provided to the function.

The following source code is an example of function with two variables which are mandatory and following optional argument list and dictionary. Note: the dictionary optional values has to be at end since it is not allowed to have a non-keyword argument after a keyword argument. This raises a +*[red]#SyntaxError:# non-keyword arg after keyword arg*+ exception.

.Example code for mix of mandatory args and optional list and keyword args
[source]
--------------------------
def func(mandatoryArg1, mandatoryArg2, *optionalList=None, **optionalDict=None):
    someList = [1,2,3]

    default = [
        {'key': foo', 'default': '123'}
        {'key': foobar', 'default': '3.14'}
    ]

    if (not optionalList is None and len(optionalList) > 0):
        someList = optionalList

    if (optionalDict is None):
        optionalDict = {}

    # get default value if not provide by callee and save it in dictionary
    foo = optionalDict.get(default[0]['key'], default[0]['default'])
    optionalDict[default[0]['key']] = foo

    foobar = optionalDict.get(default[1]['key'], default[1]['default'])
    optionalDict[default[1]['key']] = foobar

    doSomething(mandatoryArg1, mandatoryArg2, *someList, **optionalDict)
--------------------------

== Relative path from source file

If you want to call a program relative to the current source file it is not possible to just use `../bin/foobar` since `Popen()` or its equivalent `subprocess.call()` needs the absolute of the program.

.Example
[source]
--------------------------
#/usr/bin/env python
from subprocess import Popen, PIPE
from os.path import abspath, dirname, join

path = abspath(join(dirname(__file__), '../bin/foobar'))
spam, eggs = Popen(path, stdout=PIPE, stderr=PIPE).communicate()
--------------------------


== Duck-typing

[quote, 'http://docs.python.org/2/glossary.html#term-duck-typing[term-duck-typing]', python docs]
__________________________
A programming style which does not look at an object’s type to determine if it has the right interface; instead, the method or attribute is simply called or used (“If it looks like a duck and quacks like a duck, it must be a duck.”) By emphasizing interfaces rather than specific types, well-designed code improves its flexibility by allowing polymorphic substitution. Duck-typing avoids tests using type() or isinstance(). (Note, however, that duck-typing can be complemented with abstract base classes.) Instead, it typically employs hasattr() tests or EAFP programming.
__________________________

.Example with exception [https://en.wikipedia.org/wiki/Duck_typing#In_Python[wiki]]
[source]
--------------------------
try:
    mallard.quack()
except (AttributeError, TypeError):
    print("mallard can't quack()")
--------------------------    

Since `hasattr(object, name)` does almost the same job and is well optimized it should be preferred where applicable.

.Example same example with `hasattr`
[source]
--------------------------
if (hasattr(mallard, 'quack')):
    mallard.quack()
else:
    print("mallard can't quack()")
-------------------------- 


== Testing python code
In general there exists two main testing mechanisms one is http://docs.python.org/2/library/unittest.html[unittest] and the other is http://docs.python.org/2/library/doctest.html[doctest]. Both are good ways to verify that the code is correct. However both testing mechanisms have their drawbacks. 

While doctest clutters the docstring, it is a good way to give examples and to see if the docstring is consistent with the actual source code.

Unitetest keeps the actual testing separate from the source code, which helps to not blow up the source code, but it does not check if docstring and source code are consistent.

Nevertheless I find it a good practice to combine both methods, but to reverse the usage of docsttest. Thus, the docstring is used as a way to provide examples how to use the method and to see if the docstring is consistent with the source code. The actual and comprehensive testing is done by a unittest.

.Summary
**************************
* http://docs.python.org/2/library/unittest.html[unittest]: comprehensive testing
* http://docs.python.org/2/library/doctest.html[doctest]: provide examples in docstring and check if docstring is consistent with source code.
**************************

== Relative imports for non-package modules

In order to allow relative import for non-package modules or for package modules which are called as main (important for testing mechanisms), you have to add code to your script.

Assuming the module is in `httpserver.lib` and the main package is `httpserver`. Then you can add the following code to enable the module to be called as main script (read http://www.python.org/dev/peps/pep-0366/[pep-366] for more detailes).

.This code has to be place above any relative import
[source]
--------------------------
# enable relative import if this script is called as main
# see: http://www.python.org/dev/peps/pep-0366/
# if __name__ == "__main__" and __package__ is None:
#    __package__ = "expected.package.name"
# Note that this boilerplate is sufficient only if the top level package
# is already accessible via sys.path. Additional code that manipulates
# sys.path would be needed in order for direct execution to work without
# the top level package already being importable."
if __name__ == "__main__":       # <1>
    if __package__ is None:
        import sys
        import os
        # add "./../../" to sys.path to enable import of package httpserver
        sys.path.append(
            os.path.abspath(
                os.path.join(
                     os.path.join(os.path.dirname(__file__), ".."), "..")))
        import httpserver    # load main package to enable relative module import
        __package__ = "httpserver.lib"
--------------------------    
<1> If the current module is loaded from another module, which is called as main, this `if` has to be omitted.


== Python and optimization

If you run a python script without optimization this is normally invoked in debug mode (check https://docs.python.org/2/library/constants.html?highlight=%5F%5Fdebug%5F%5F#%5F%5Fdebug%5F%5F[\\__debug__]). This means for example that all
assertions will be tested. You can test if python is running in debug mode by invoking following code:
[source, shell]
--------------------------
    $ python -c 'print __debug__'
    True
    $ python -c 'assert False, "assert"'
    Traceback (most recent call last):
      File "<string>", line 1, in <module>
    AssertionError: assert
--------------------------

Turning optimization on by passing `-O` or `-OO` to python, will optimize the script (the latter will also discard the docstring in favor for optimal code), which includes that alle assertions
will be ignored (see `man python` or https://docs.python.org/2/using/cmdline.html?highlight=#-O[html] for more details;
or just invoke `python -h`). 
[source, shell]
--------------------------
    $ python -OO -c 'print __debug__'
    False
    $ python -O -c 'assert False, "assert"'
    <blank> # <- assertion should have been thrown if it wasn't be ignored
--------------------------

TIP: For testing you should run your scripts in debug mode. To deploy or running the scripts in actual task (assuming you
have tested everything properly) you should run your scripts in optimzation mode.


== Check if assertion turned off
Assertions are useful for several things such as:

* Design by contract (pre-/post condition test)
* Early recognition of bugs
* etc.

They should be used only for checking the code and not for flow control or other
things. For this case `if ... else` or `try ... except ... finally` are made for.

If you want to deploy the software you always should turn `DEBUG` to `0` and shall
either write wrapper script which calls the script with the python command `-O` or
you should highlight that the script shall be called with this command.

In some cases assertions can slow down the code, this is why you should use the 
optimization mode of python. To ensure this, you can insert following code
snippet in your main file or setting file which checks if python ignores all 
assertions otherwise it throws an assertion with a description.

[source]
--------------------------
DEBUG = 0
if not DEBUG:
    import sys
    import os
    as_msg = """This script has been configured such it runs in release mode. 
    Since the scripts makes excessive use of assertion for development you should 
    run this script with "python -O {script_name}" to neglect assertions or 
    switch back to debug mode by setting setting.DEBUG = 1.
""".format(script_name=os.path.basename(sys.argv[0]))
    assert False, as_msg
--------------------------

For a more detailed description of assertions and how to use them read https://mail.python.org/pipermail/python-list/2013-November/660401.html[When to use assert].


== Properties
[IMPORTANT]
Python is not Java or C/C++ -> There are no private member variables which shall
be accessed by getter/setter functions. Thus, don't write getter/setter functions
but access all variables directly unless not otherwise possible or meaningful. Then
use properties!

A big advantage of using property decorator for setting/getting is to have 
control of how variables should be read from or written to. For example you want
want to prevent a variable to be positive (validating) or before you returning a variable
you want to recompute something etc. This can be ensured by ordinary getter/setter
methods or by the `@property` decorator. The property decorator is superior when
code should be more flexible. For instance if you have written a Library which has
been deployed already and you decided to instead of just returning a value you want
to recompute or refetch from remote a new value which shall be returned. Thus you
can hide this behavior behind the property decorator without braking code which 
uses your library. Additionally if you decided to recompute or update something
when a variable changes you can also hide this in property setter method without
braking existing code.

One disadvantage is the reduced performance which, in most cases, can be neglected.

Another area where the property is useful is design-by-contract where you always
can check pro/post condition and class invariants in the development stage and when
it comes to the release mode you can just roll back and rename all variables and 
comment the property decorator to be as efficient as possible.

In addition you don't have to write getter/setter just in case you want to have
control. You can write a variable without the double underscores and if you 
decide you want to have more control added properties for those variables and change
the local variable to have leading underscores but not using refactoring in this 
case which would change all access to this variable also.

.Syntactic sugar
[NOTE]
This concept is in general syntactic sugar which allows method calls to like 
variable access or assignment.

=== Decorator

TIP: Read http://legacy.python.org/dev/peps/pep-0318/[pep-318] for more information

Decorate each function with purpose. `@property` has to start each property.

.Example code
[source]
--------------------------
class Sphere(object):
    def __init__(self, radius, center):
        self._radius = radius
        self._center = center
    
    @property
    def radius(self):
        print "radius getter is used"
        return self.__radius
        
    @radius.setter
    def radius(self, radius):
        if radius < 0:
            raise TypeError("Radius should never be negative")
        self.__radius = radius
        
>>> s = Sphere(1, [1,1,1])
>>> s.radius = 2
>>> print s.radius
radius getter is used
2
>>> s.radius = -1
TypeError: Radius should never be negative
>>> print s.radius
radius getter is used
2
--------------------------

* Convention for private variables http://docs.python.org/3/tutorial/classes.html#private-variables[private-variables].
* Another good link to why to use http://stackoverflow.com/a/6618176/1959528[stackoverflow.com]


=== Using constructor

Source: article: http://tomayko.com/writings/getters-setters-fuxors

Calling http://docs.python.org/2/library/functions.html?highlight=property#property[property constructor] for each property.

.Example code
[source]
--------------------------
class Contact(object):

    def __init__(self, first_name=None, last_name=None, 
                 display_name=None, email=None):
        self.first_name = first_name
        self.last_name = last_name
        self.display_name = display_name
        self.email = email

    def print_info(self):
        print self.display_name, "<" + self.email + ">"            

    def set_email(self, value):
        if '@' not in value:
            raise Exception("This doesn't look like an email address.")
        self._email = value

    def get_email(self):
        return self._email

    email = property(get_email, set_email)
--------------------------

The following code will still run properly but now checks if email contains a '@':

.Example code
[source]
--------------------------
contact = Contact()
contact.email = "x@x.com"   # ok
contact.email = "xx.com"    # Exception
--------------------------

=== Private variables

"Any identifier of the form \__spam (at least two leading underscores, at most one trailing underscore) is textually replaced with _classname\__spam, where classname is the current class name with leading underscore(s) stripped." 
This prevents a sublcass from using self.__spam!

.Example code
[source]
--------------------------
class C(object):
    __name = None
    _name2 = None
    
class D(C):
    pass
    
>>> d = D()
>>> dir(d)
['_C__name',        # <<< notice _C in front of name -> thus, this variable can be used in the current Class only
 '__class__',
 '__delattr__',
 '__dict__',
 '__doc__',
 '__format__',
 '__getattribute__',
 '__hash__',
 '__init__',
 '__module__',
 '__new__',
 '__reduce__',
 '__reduce_ex__',
 '__repr__',
 '__setattr__',
 '__sizeof__',
 '__str__',
 '__subclasshook__',
 '__weakref__',
 '_name2']          # <<< has not been changed -> thus, this property can be easily used in sublcasses

--------------------------


== @override and @implements decorators

The following `@overrides` and `@implements` decoratos can be used to show
that the following functions overrides or implements the method from super class.
It also copies the `__doc__` string from the super method if it is not specified
in the new function. http://pydev.blogspot.de/2011/06/overrideimplements-templates-on-pydev.html[src]

.decoratos.py
[source]
--------------------------
def overrides(method):
    def wrapper(func):
        if func.__name__ != method.__name__:
            msg = "Wrong @override: %r expected, but overwriting %r."
            msg = msg % (func.__name__, method.__name__)
            raise AssertionError(msg)

        if func.__doc__ is None:
            func.__doc__ = method.__doc__

        return func

    return wrapper


def implements(method):
    def wrapper(func):
        if func.__name__ != method.__name__:
            msg = "Wrong @implements: %r expected, but implementing %r."
            msg = msg % (func.__name__, method.__name__)
            raise AssertionError(msg)

        if func.__doc__ is None:
            func.__doc__ = method.__doc__

        return func

    return wrapper
--------------------------

== Docstring copy with decorators

NOTE: Heavily borrowed from https://github.com/matplotlib/matplotlib[matplotlib]. https://github.com/matplotlib/matplotlib/blob/master/lib/matplotlib/docstring.py[docstring.py]

This decorator can be used to copy the docstring from function to another. This is usefule in cases where a wrapper function
calls an internal function which does mostly the same and has the same interface.

IMPORTANT: Instead of writing your own `docstring.py` please consider to use that provided by `matplotlib`: `from matplotlib import docstring`

.docstring.py
[source]
--------------------------
import re

# A regular expression used to determine the amount of space to
# remove.  It looks for the first sequence of spaces immediately
# following the first newline, or at the beginning of the string.
_find_dedent_regex = re.compile("(?:(?:\n\r?)|^)( *)\S")
# A cache to hold the regexs that actually remove the indent.
_dedent_regex = {}

def _dedent(s):
    """
    Remove excess indentation from docstring *s*.

    Discards any leading blank lines, then removes up to n whitespace
    characters from each line, where n is the number of leading
    whitespace characters in the first line. It differs from
    textwrap.dedent in its deletion of leading blank lines and its use
    of the first non-blank line to determine the indentation.

    It is also faster in most cases.
    """
    # This implementation has a somewhat obtuse use of regular
    # expressions.  However, this function accounted for almost 30% of
    # matplotlib startup time, so it is worthy of optimization at all
    # costs.

    if not s:      # includes case of s is None
        return ''

    match = _find_dedent_regex.match(s)
    if match is None:
        return s

    # This is the number of spaces to remove from the left-hand side.
    nshift = match.end(1) - match.start(1)
    if nshift == 0:
        return s

    # Get a regex that will remove *up to* nshift spaces from the
    # beginning of each line.  If it isn't in the cache, generate it.
    unindent = _dedent_regex.get(nshift, None)
    if unindent is None:
        unindent = re.compile("\n\r? {0,%d}" % nshift)
        _dedent_regex[nshift] = unindent

    result = unindent.sub("\n", s).strip()
    return result

def dedent(func):
    "Dedent a docstring (if present)"
    func.__doc__ = func.__doc__ and _dedent(func.__doc__)
    return func

def copy_dedent(source):
    """A decorator that will copy the docstring from the source and
    then dedent it"""
    # note the following is ugly because "Python is not a functional
    # language" - GVR. Perhaps one day, functools.compose will exist.
    #  or perhaps not.
    #  http://mail.python.org/pipermail/patches/2007-February/021687.html
    return lambda target: dedent(copy(source)(target))

def copy(source):
    "Copy a docstring from another source function (if present)"
    def do_copy(target):
        if source.__doc__:
            target.__doc__ = source.__doc__
        return target
    return do_copy

class Appender(object):
    """
    A function decorator that will append an addendum to the docstring
    of the target function.

    This decorator should be robust even if func.__doc__ is None
    (for example, if -OO was passed to the interpreter).

    Usage: construct a docstring.Appender with a string to be joined to
    the original docstring. An optional 'join' parameter may be supplied
    which will be used to join the docstring and addendum. e.g.

    add_copyright = Appender("Copyright (c) 2009", join='\n')

    @add_copyright
    def my_dog(has='fleas'):
        "This docstring will have a copyright below"
        pass
    """
    def __init__(self, addendum, join=''):
        self.addendum = addendum
        self.join = join

    def __call__(self, func):
        docitems = [func.__doc__, self.addendum]
        func.__doc__ = func.__doc__ and self.join.join(docitems)
        return func
--------------------------

//////////////////////////
CommentBlock:     //////////////////////////
PassthroughBlock: ++++++++++++++++++++++++++
ListingBlock:     --------------------------
LiteralBlock:     ..........................
SidebarBlock:     **************************
QuoteBlock:       __________________________
ExampleBlock:     ==========================
OpenBlock:        --
//////////////////////////
