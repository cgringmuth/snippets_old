= A List of python Tips, Tricks and Idioms
:Author:                Christoph Hoffmann
:Email:                 choffmann1983@gmail.com
:Revision:              3.1415926
:source-highlighter:    highlight
:numbered:
:toc:                   // set table of content
:icons:                 // search for icons in :inconsdir: (default: ./images/icons.)
:iconsdir:              ../asciidoc/images/icons
:imagesdir:             ../asciidoc/images/
// :scriptsdir:            ../asciidoc/js
// :linkcss:

== Introduction

TODO

== Shebang 

[TIP]
Detailed description at source: https://en.wikipedia.org/wiki/Shebang_(Unix)[wikipedia.org]

Shebang ist used let the operation system know how to interpret the given script. Such shebang hast be placed at the top of each file.

[source,python]
----
#!/usr/bin/env python
----


== Enum in python

[source,python]
----
def enum(*sequential, **named):
    '''
    Example:  num = enum(ONE=1, TWO=2, THREE='three')
              num.ONE >>> 1
    Support for converting the values back to names can be added this way:
              num.reverse_mapping[2] >> 'TWO'
    Source: http://stackoverflow.com/a/1695250
    '''
    enums = dict(zip(sequential, range(len(sequential))), **named)
    reverse = dict((value, key) for key, value in enums.iteritems())
    enums['reverse_mapping'] = reverse
    return type('Enum', (), enums)
----    


== Python Imaging Library (http://www.pythonware.com/products/pil/[PIL])

PIL is a good library to handle images in python.

Installing the PIL on Ubuntu 64 bit revealed some issues.

[quote, anonymous]
It turns out that the APT installations put the libraries under '/usr/lib/x86_64-linux-gnu' and PIL will search for them in '/usr/lib/'. So you have to create symlinks for PIL to see them.

[source,shell]
----
ln -s /usr/lib/x86_64-linux-gnu/libjpeg.so /usr/lib
ln -s /usr/lib/x86_64-linux-gnu/libfreetype.so /usr/lib
ln -s /usr/lib/x86_64-linux-gnu/libz.so /usr/lib
----
Source: http://jj.isgeek.net/2011/09/install-pil-with-jpeg-support-on-ubuntu-oneiric-64bits/



== Importing libs in main only

Sometimes libs are only needed if a lib is called as main process. Thus, it is meaningful to import such libs only if this module is called as main process. 

[source,python]
----
if __name__ == '__main__':
    from paste import httpserver    # Paste <http://pythonpaste.org>
    httpserver.serve(app, host='127.0.0.1', port=8080)  
----

or

[source,python]
----
if __name__ == '__main__':
    import sys
    main(sys.argv[1:])
----


== Use "with" for files 

[TIP]
Detailed description at source: http://docs.python.org/2/tutorial/inputoutput.html#methods-of-file-objects[docs.python.org]

It is good practice to use the with keyword when dealing with file objects. This has the advantage that the file is properly closed after its suite finishes, even if an exception is raised on the way. It is also much shorter than writing equivalent try-finally blocks:

[source,python]
----
with open('workfile', 'r') as f:
    read_data = f.read()

doOtherStuff()  # <1>
----
<1> f is closed here automatically even if  an exception raised

or with multiple files

[source,python]
----
with open('a', 'w') as a, open('b', 'w') as b:
    data_a = a.read()
    data_b = b.read()

doOtherStuff()  # <1>
----
<1> a and b are closed here automatically even if  an exception raised


:test_link: http://www.python.org/dev/peps/pep-0008/#global-variable-names[#]
== \_\_all__ mechanism

Use \_\_all__ mechanism to prevent name clashes if you import a module by _from M import *_ [Source: {test_link}]

.foobar.py
[source,python]
----
# Specify what is visible from other modules if current module imported by
# from M import *
__all__ = ['foobar'] # only foobar is visible


foobar = 'hey'
foobarprivate = 'should not be seen'
----

.main.py
[source,python]
----
from foobar import *

foobar          # <1>
foobarprivate   # <2>
----
<1> Ok
<2> Error


== Class to handle a bunch of different variables 

[TIP]
Detailed description at source: http://code.activestate.com/recipes/52308-the-simple-but-handy-collector-of-a-bunch-of-named/?in=user-97991[code.activestate.com]

[source, python]
----
class Bunch(dict):
    def __init__(self, **kw):
        dict.__init__(self, kw)     # <1>
        self.__dict__.update(kw)

# that's it!  Now, you can create a Bunch
# whenever you want to group a few variables:

point = Bunch(datum=y, squared=y*y, coord=x)

# and of course you can read/write the named
# attributes you just created, add others, del
# some of them, etc, etc:
if point.squared > threshold:
    point.isok = 1
----

<1> This has the added benefit that it can directly be printed and it shows its contents in interactive environments like ipython.


== Dictionary default value 

[TIP]
Detailed description at source: http://stackoverflow.com/questions/101268/hidden-features-of-python[stackoverflow.com]

[source,python]
----
d = {}                      # empty dictionary
dafaultKey = 1234           # default value for key
d['key']                    # -> exception 'KeyError'
d.get('key')                # -> None
d.get('key', dafaultKey)    # -> defaultKey = 1234
# Great for:
d['key'] = d.get('key', dafaultKey) + 1
----


== How to write binary bits to a file

[source,python]
----
import struct                               # <1>

num = [1,2,3,4]

# 'B' : unsigned byte -> 0..255
data = struct.pack('BBBB', *num)            # <2>
# more general:
data = struct.pack('B' * len(num), *num)    # <2>

filename = 'test.bin'
with open(filename, 'wb') as f:
    f.write(data)
----

<1> Link: http://docs.python.org/2/library/struct.html[struct]
<2> Link: http://docs.python.org/2/library/struct.html#struct.pack[struct.pack]


== Mandatory vs. Optional Arguments

Sometimes it is useful to have arguments which are mandatory while others are not necessary because they can be predicted, inferred by other values or they have some default values.

[source,python]
----
def func(v1, v2, **args):
    defaultV3 = -1
    v3 = args.get('v3', defaultV3)
    print v1, v2, v3

func(1, 2, v3=22)       # <1>
func(1, 2)              # <2>
----
<1> >>> 1  2 22
<2> >>> 1 2 -1


== List all Folders

[source,python]
----
import os


folder = [f for f in os.listdir('.') if os.path.isdir(f)]                       # <1>

of = '/path/to/other/folder'         # working folder
folder = [f for f in os.listdir(of) if os.path.isdir(os.path.join(of, f))]      # <2>
----

<1> Only works if one is looking for folders in the current folder
<2> More general case



== List Comprehensions 

[TIP]
Detailed description at source: http://docs.python.org/2.7/tutorial/datastructures.html#list-comprehensions[docs.python.org]

Compact way to generate specific lists.

[source,python]
----
[(x, y) for x in [1, 2, 3] for y in [3, 1, 5] if x!=z]  # <1>
----

<1> >>> [(1, 3), (1, 5), (2, 3), (2, 1), (2, 5), (3, 1), (3, 5)]

=== Unpacking list in list

[source,python]
----
vec = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
[num for elem in vec for num in elem]   # <1>
----

<1> >>> [1, 2, 3, 4, 5, 6, 7, 9]

=== Nested list comprehension

[source,python]
----
matrix = [
    [1, 5, 9],
    [2, 6, 10],
    [3, 7, 11],
    [4, 8, 12]
]

matrix_trans = [[row[n] for row in matrix] for n in range(len(matrix))]  
print matrix_trans      # <1>
----

<1> >>> \[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]


=== Slice copy when changing a list while iterate over same list

To change a sequence you are iterating over while inside the loop (for example to duplicate certain items), it is recommended that you first make a copy. Looping over a sequence does not implicitly make a copy. The slice notation makes this especially convenient [http://docs.python.org/2.7/tutorial/datastructures.html#looping-techniques[#]]:

[source,python]
----
words = ['cat', 'window', 'defenestrate']
for w in words[:]:  # Loop over a slice copy of the entire list.
    if len(w) > 6:
        words.insert(0, w)

words       # <1>
----

<1> >>> ['defenestrate', 'cat', 'window', 'defenestrate']

== Looping Techniques 

[TIP]
==========================
* Detailed description at source: http://docs.python.org/2.7/tutorial/datastructures.html#looping-techniques[docs.python.org]
* todo
==========================


=== List

To retreive index and value use `enumerate()`.

[source,python]
----
for i, v in enumerate(['tic', 'tac', 'toe']):
    print i, v
----

=== Dictionary

Iterate over the complete dictionary.

[source,python]
--------------------------
knights = {'gallahad': 'the pure', 'robin': 'the brave'}
for k, v in knights.iteritems():
    print k, v
--------------------------


//////////////////////////
CommentBlock:     //////////////////////////
PassthroughBlock: ++++++++++++++++++++++++++
ListingBlock:     --------------------------
LiteralBlock:     ..........................
SidebarBlock:     **************************
QuoteBlock:       __________________________
ExampleBlock:     ==========================
OpenBlock:        --
//////////////////////////