= A List of +C+ Tips, Tricks and recipes/idioms
:Author:                Christoph Hoffmann
:Email:                 choffmann1983@gmail.com
:Revision:              0.0.1 'http://semver.org/[(semver)]'
:source-highlighter:    highlight
:numbered:
:toc:                   // set table of content
:icons:                 // search for icons in :inconsdir: (default: ./images/icons.)
:iconsdir:              ../asciidoc/images/icons
:imagesdir:             ../asciidoc/images/
// :scriptsdir:            ../asciidoc/js
// :linkcss:

:language:              c

== Introduction

todo ...

Here is a list of interesting links:

* http://ivory.idyll.org/articles/advanced-swc/[Intermediate and Advanced Software Carpentry in Python]
* http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html[Code Like a Pythonista: Idiomatic Python]
* http://code.activestate.com/recipes/langs/python/[Popular Python recipes ]

== List of good literature

* http://www.gnu.org/software/libc/manual/pdf/libc.pdf[The GNU C Library
Reference Manual]
* https://www.kernel.org/doc/Documentation/CodingStyle[Linux kernel coding style]
* http://lwn.net/Articles/250967/[What every programmer should know about memory, Part 1]
* http://lwn.net/Articles/336224/[Linux kernel design patterns - part 1]
* https://lwn.net/Kernel/LDD3/[Linux Device Drivers, Third Edition]
* todo

== GNU building tools

Before starting developing, you should read the https://www.gnu.org/prep/standards/[GNU coding standards] even though you are not intending to write GNU software.

A list of https://www.gnu.org/manual/[GNU manuals].

There is a package called https://www.gnu.org/software/hello/[hello] (https://www.gnu.org/software/hello/manual/[hello manual]) in the gnu project which serves as an example GNU package following good practice and the GNU coding standards. If one wants to write or maintain a GNU package, this package can be a starting point. It is based on `automake` and `autoconf` to be portable. To get the source of the package just invoke following command: `apt-get source hello`. If you just want to download that package invoke following command: `apt-get download hello`.

=== Make
[NOTE]
==========================
* https://www.gnu.org/software/make/[*gnu make*] - GNU make utility to maintain groups of  
    programs 
* https://www.gnu.org/software/make/[make manual]
* http://c.learncodethehardway.org/book/ex2.html[Make Is Your Python Now]: for a nice introduction
==========================

Make knows how to build most of the source files. For example if you have a file named `foo.c` and invoke `make foo`. Make will call `cc foo.c -o foo`. If you want to set flags you can do this by invoking `CFLAGS="-Wall -g" make foo` which will result in `cc -Wall -g foo.c -o foo`. And if you want to to change the compiler you can do this by setting the `CC` flags like so: `CFLAGS="-Wall -g" CC=gcc make foo` which results in `gcc -Wall -g foo.c -o foo`.

But is it more convenient to write makefiles which is a textfile which is loaded and interpreted by make if it is in the same folder and is called `makefile`.

==== Makefile

Some https://www.gnu.org/prep/standards/html_node/Makefile-Conventions.html#Makefile-Conventions[general conventions] from gnu.org.

.Example of typical target
[source, shell]
--------------------------
target: dependencies ..
[tab]   commands
        ...
--------------------------

Every Makefile should contain this line:

    SHELL = /bin/sh

to avoid trouble on systems where `SHELL` variable might inherited from the environment.

Programs for building and compiling should be called by variables to enable users to substitute alternatives. For example following commands:

    'ar bison cc flex install ld ldconfig lex make makeinfo ranlib texi2dvi yacc'

should be called with following variables:

    '$(AR) $(BISON) $(CC) $(FLEX) $(INSTALL) $(LD) $(LDCONFIG) $(LEX)
    $(MAKE) $(MAKEINFO) $(RANLIB) $(TEXI2DVI) $(YACC)'


===== Using multiple targets

WARNING: Is not correct. Has to be revised!

If you want to compile multiple targets which should be compiled to the same name you can use `$<` which returns the depending filenames and `$@` which returns the target name.

.Example of using $< and $@
[source, shell]
--------------------------
CFLAGS = -Wall -g
SRC = prog1 prog2

all: $(SRC)

$(SRC): $(SRC).c
    $(CC) $(CFLAGS) $< -o $@ 

clean: 
    rm -r $(SRC)
--------------------------
Calling `make` results `prog1` and `prog2` assuming their exist `prog1.c` and `prog2.c`.


.Brief summary of http://www.gnu.org/software/make/manual/make.html#Automatic-Variables[Automatic variables]
--------------------------
For more detailes just go to http://www.gnu.org/software/make/manual/make.html#Automatic-Variables[Automatic variables]

* `$@` The name of the target file (the one before the colon)
* `$<` The name of the first (or only) prerequisite file (the first one after the colon)
* `$^` The names of all the prerequisite files (space separated)
* `$*` The stem (the bit which matches the % wildcard in the rule definition.
--------------------------



===== http://www.gnu.org/software/make/manual/make.html#Target_002dspecific[Target specific variables]

If it is required to set target specific variables you can use the targe specific variables. For example if you want a target which sets a macro `TEST`, following code will do the trick:

[source, shell]
--------------------------
CFLAGS = -Wall -g
SRC = prog1 prog2

all: $(SRC)

test: CFLAGS += -DTEST
test: $(SRC) 

clean: 
    rm -r $(SRC)
--------------------------

Calling `make test` will compile likewise the target `all` expect that the `TEST` macro will be set, which can be used in the source code.


=== gcc
--------------------------
GNU project C and C++ compiler
--------------------------

If you want to know the default include paths you have to consulte the used preprocessor which is in charge of replaceing all preprocessor commands including `#include` with actual valid C/C++ code. Just use `cpp -v` to show the required information.


===== gcc dump preprocessor defines

[source, shell]
--------------------------
$ gcc -dM -E - < /dev/null
--------------------------

examples

[source, shell]
--------------------------
$ gcc -dM -E -msse4 - < /dev/null | grep SSE[34]
--------------------------


How do I dump preprocessor macros coming from a particular header file:

[source, shell]
--------------------------
$ echo "#include <sys/socket.h>" | gcc -E -dM - | grep SOMAXCONN
#define SOMAXCONN 128
--------------------------

=== cpp             
--------------------------
The C Preprocessor
--------------------------

"The C preprocessor, often known as cpp, is a macro processor that is used automatically by the C compiler to transform your program before
compilation.  It is called a macro processor because it allows you to define macros, which are brief abbreviations for longer constructs."


`cpp -v` is the verbose mode which depicts the default include paths and other useful information. If you're working with microcontroller you might be familiar with the `avr-*` applications (especially if you're working with arduino or other prototype boards). For the avr system a preprocessor 'avr-cpp' exits also, which can be used, inter alia, to figure out where to find the default including files: `avr-cpp -v`.

=== ldd             
--------------------------
Print shared library dependencies
--------------------------

=== ld              
--------------------------
The GNU linker
--------------------------

todo

=== readelf         
--------------------------
Displays information about ELF file
--------------------------

todo

=== pkg-config      
--------------------------
Return metainformation about installed libraries
--------------------------

todo

=== ldconfig        
--------------------------
Configure dynamic linker run-time bindings
--------------------------

todo
    
=> ldconfig -p: list all installed/loaded libraries
        -> ldonfig -p | grep -i opencv: find all libraries which contains opencv

=== valgrind        
--------------------------
A suite of tools for debugging and profiling programs
--------------------------

todo


=== Configure script

http://www.gnu.org/prep/standards/html_node/Directory-Variables.html[Coding standards: Directory Variables] also for autoconf

todo


=== Autoconf
--------------------------
Generate configuration scripts
--------------------------

todo

=== Automake

todo


=== Patching changes

==== diff             
NOTE: *diff* - compare files line by line

compare files line by line
    -> recommended way of using for patching: diff -Naur old new &> fix.patch
    Example:
        . ls => file1 newfile1
        . diff -Naur file1 newfile1 &> fix.patch 
            -> fix.patch conatins everything which has been changed in newfile1 compared to file1
        . ls => file1 newfile1 fix.patch

==== patch            
NOTE: *patch* - apply a diff file to an original

apply a diff file to an original

    Example:
        . patch -p0 -b < fix.patch
        . file1 == newfile1
        . -b: makes backup of the patched file > file1.orig

== Workflow

=== if

[source]
--------------------------
if(condition) {
    statement
} else if(condition) {
    statement
} else {
    statement
}
--------------------------



//////////////////////////
CommentBlock:     //////////////////////////
PassthroughBlock: ++++++++++++++++++++++++++
ListingBlock:     --------------------------
LiteralBlock:     ..........................
SidebarBlock:     **************************
QuoteBlock:       __________________________
ExampleBlock:     ==========================
OpenBlock:        --
//////////////////////////
