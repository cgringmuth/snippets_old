= A List of +C+ Tips, Tricks and recipes/idioms
:Author:                Christoph Hoffmann
:Email:                 choffmann1983@gmail.com
:Revision:              0.0.1 'http://semver.org/[(semver)]'
:source-highlighter:    highlight
:numbered:
:toc:                   // set table of content
:icons:                 // search for icons in :inconsdir: (default: ./images/icons.)
:iconsdir:              ../asciidoc/images/icons
:imagesdir:             ../asciidoc/images/
// :scriptsdir:            ../asciidoc/js
// :linkcss:

:language:              c

== Introduction

todo ...

Here is a list of interesting links:

* http://ivory.idyll.org/articles/advanced-swc/[Intermediate and Advanced Software Carpentry in Python]
* http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html[Code Like a Pythonista: Idiomatic Python]
* http://code.activestate.com/recipes/langs/python/[Popular Python recipes ]

== Tools (GNU)

Before starting developing, you should read the https://www.gnu.org/prep/standards/[GNU coding standards] even though you are not intending to write GNU software.

A list of https://www.gnu.org/manual/[GNU manuals].

There is a package called https://www.gnu.org/software/hello/[hello] (https://www.gnu.org/software/hello/manual/[hello manual]) in the gnu project which serves as an example GNU package following good practice and the GNU coding standards. If one wants to write or maintain a GNU package, this package can be a starting point. It is based on `automake` and `autoconf` to be portable. To get the source of the package just invoke following command: `apt-get source hello`. If you just want to download that package invoke following command: `apt-get download hello`.

=== Make
[NOTE]
==========================
* https://www.gnu.org/software/make/[*gnu make*] - GNU make utility to maintain groups of  
    programs 
* https://www.gnu.org/software/make/[make manual]
* http://c.learncodethehardway.org/book/ex2.html[Make Is Your Python Now]: for a nice introduction
==========================

Make knows how to build most of the source files. For example if you have a file named `foo.c` and invoke `make foo`. Make will call `cc foo.c -o foo`. If you want to set flags you can do this by invoking `CFLAGS="-Wall -g" make foo` which will result in `cc -Wall -g foo.c -o foo`. And if you want to to change the compiler you can do this by setting the `CC` flags like so: `CFLAGS="-Wall -g" CC=gcc make foo` which results in `gcc -Wall -g foo.c -o foo`.

But is it more convenient to write makefiles which is a textfile which is loaded and interpreted by make if it is in the same folder and is called `makefile`.

==== Makefile

Some https://www.gnu.org/prep/standards/html_node/Makefile-Conventions.html#Makefile-Conventions[general conventions] from gnu.org.

.Example of typical target
[source, shell]
--------------------------
target: dependencies ..
[tab]   commands
        ...
--------------------------

Every Makefile should contain this line:

    SHELL = /bin/sh

to avoid trouble on systems where `SHELL` variable might inherited from the environment.

Programs for building and compiling should be called by variables to enable users to substitute alternatives. For example following commands:

    'ar bison cc flex install ld ldconfig lex make makeinfo ranlib texi2dvi yacc'

should be called with following variables:

    '$(AR) $(BISON) $(CC) $(FLEX) $(INSTALL) $(LD) $(LDCONFIG) $(LEX)
    $(MAKE) $(MAKEINFO) $(RANLIB) $(TEXI2DVI) $(YACC)'


===== Using multiple targets

WARNING: Is not correct. Has to be revised!

If you want to compile multiple targets which should be compiled to the same name you can use `$<` which returns the depending filenames and `$@` which returns the target name.

.Example of using $< and $@
[source, shell]
--------------------------
CFLAGS = -Wall -g
SRC = prog1 prog2

all: $(SRC)

$(SRC): $(SRC).c
    $(CC) $(CFLAGS) $< -o $@ 

clean: 
    rm -r $(SRC)
--------------------------
Calling `make` results `prog1` and `prog2` assuming their exist `prog1.c` and `prog2.c`.


===== http://www.gnu.org/software/make/manual/make.html#Target_002dspecific[Target specific variables]

If it is required to set additional variables you can use the targe specific variables which will be set only for the targe. For example if you have a macro `TEST` and want a traget which is called similar you can do the following:

--------------------------
CFLAGS = -Wall -g
SRC = prog1 prog2

all: $(SRC)

test: CFLAGS += -DTEST
test: $(SRC) 

clean: 
    rm -r $(SRC)
--------------------------

Here, when calling `make test` it will set the macro `TEST`.

=== gcc
--------------------------
GNU project C and C++ compiler
--------------------------

todo

=== cpp             
--------------------------
The C Preprocessor
--------------------------

todo

=== ldd             
--------------------------
Print shared library dependencies
--------------------------

=== ld              
--------------------------
The GNU linker
--------------------------

todo

=== readelf         
--------------------------
Displays information about ELF file
--------------------------

todo

=== pkg-config      
--------------------------
Return metainformation about installed libraries
--------------------------

todo

=== ldconfig        
--------------------------
Configure dynamic linker run-time bindings
--------------------------

todo
    
=> ldconfig -p: list all installed/loaded libraries
        -> ldonfig -p | grep -i opencv: find all libraries which contains opencv

=== valgrind        
--------------------------
A suite of tools for debugging and profiling programs
--------------------------

todo


=== Autoconf
--------------------------
Generate configuration scripts
--------------------------

todo

=== Automake

todo


=== Patching changes

==== diff             
NOTE: *diff* - compare files line by line

compare files line by line
    -> recommended way of using for patching: diff -Naur old new &> fix.patch
    Example:
        . ls => file1 newfile1
        . diff -Naur file1 newfile1 &> fix.patch 
            -> fix.patch conatins everything which has been changed in newfile1 compared to file1
        . ls => file1 newfile1 fix.patch

==== patch            
NOTE: *patch* - apply a diff file to an original

apply a diff file to an original

    Example:
        . patch -p0 -b < fix.patch
        . file1 == newfile1
        . -b: makes backup of the patched file > file1.orig

== Workflow

=== if

--------------------------
if(condition) {
    statement
} else if(condition) {
    statement
} else {
    statement
}
--------------------------



//////////////////////////
CommentBlock:     //////////////////////////
PassthroughBlock: ++++++++++++++++++++++++++
ListingBlock:     --------------------------
LiteralBlock:     ..........................
SidebarBlock:     **************************
QuoteBlock:       __________________________
ExampleBlock:     ==========================
OpenBlock:        --
//////////////////////////
